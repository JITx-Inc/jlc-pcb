#use-added-syntax(jitx,tests)
defpackage jlc-pcb/tests/stackups :
  import core
  import collections
  import jitx
  import jitx/commands
  import jsl/layerstack
  import jsl/tests/layerstack
  import jlc-pcb/shared
  import jlc-pcb/stackups
  import jlc-pcb/basic-rules
  import esir/ir

deftest make-JLC04161H-7628 :
  val test-stackup = jlc-pcb/JLC04161H-7628/stackup
  print-def(test-stackup)
  println(get-def-string(test-stackup))
  ; => "pcb-stackup D90custom-stackup"
  println(test-stackup)
  ; => "Stackup JLC04161H-7628"

  val test-stack = jlc-pcb/JLC04161H-7628/stack
  verify-layers(test-stack, top-layers) where :
    val core = FR4("core", 1.065, "core")
    val prepreg = FR4("7628", 0.2104, "7628x1")
    val top-layers = 
      [ 
        copper-35um
        prepreg
        copper-15_2um
        core
      ]

deftest make-JLC04161H-7628-from-name :
  val test-stackup = create-pcb-stackup-from-name("JLC04161H-7628")
  print-def(test-stackup)
  
  ;TODO: comparison of two pcb-stackup
  ;#EXPECT(test-stackup == jlc-pcb/JLC04161H-7628/stackup)

; three adjacent prepreg layers
deftest make-JLC04161H-7628B-from-name :
  val test-stackup = create-pcb-stackup-from-name("JLC04161H-7628B")
  print-def(test-stackup)

  ;val stmts = statements(test-stackup)
  ;println(stmts)

;TODO: print-def for pcb-routing-structure does not work
deftest test-routing-structure :
  val test-routing = jlc-pcb/JLC04161H-7628/SE-50
  print-def(test-routing)
  ; => pcb-routing-structure D78SE-50
  ;    name = SE-50
  ;      routing-layer(LayerIndex(0)) : ()
  ;      routing-layer(LayerIndex(0, Bottom)) : ()

defn diff-clearances (a:Tuple<RuleClearance>, b:Tuple<RuleClearance>) -> Tuple<[RuleClearance|False RuleClearance]> :
  val diffs = Vector<[RuleClearance|False RuleClearance]>()
  val table = to-hashtable<ClearanceType,RuleClearance>(map({type(_0) => _0} a))
  ;println("A => %_" % [qsort({to-int $ type(_)} a)])
  ;println("B => %_" % [qsort({to-int $ type(_)} b)])
  ;qsort({to-int $ type(_)} a) == qsort({to-int $ type(_)} b)
  for rule in b do:
    match(get?(table type(rule))):
      (a:RuleClearance) :
        if value(a) != value(rule) :
          add(diffs, [a rule])
      (a:False):
        add(diffs, [false rule])
  to-tuple $ diffs

defn compare-clearances (a:Tuple<RuleClearance>, b:Tuple<RuleClearance>) :
  ;println("A => %_" % [qsort({to-int $ type(_)} a)])
  ;println("B => %_" % [qsort({to-int $ type(_)} b)])
  qsort({to-int $ type(_)} a) == qsort({to-int $ type(_)} b)

deftest test-basic-rules1 :
  val test-base = jlc-pcb/basic-rules/jlcpcb-basic-rules-from-ocdb 
  val test-rules = jlc-pcb/basic-rules/rules1
  ;print-def(test-rules)
  ;println(clearances(test-rules))
  ;#EXPECT(clearances(test-rules) == clearances(test-base))
  #EXPECT(compare-clearances(clearances(test-rules), clearances(test-base)))

deftest test-basic-rules2 :
  val test-base = jlc-pcb/basic-rules/rules2
  val test-rules = jlc-pcb/basic-rules/rules
  ;print-def(test-rules)
  ;println(clearances(test-rules))
  ;#EXPECT(clearances(test-rules) == clearances(test-base))
  ;#EXPECT(compare-clearances(clearances(test-rules), clearances(test-base)))
  #EXPECT(empty? $ diff-clearances(clearances(test-rules), clearances(test-base)))
